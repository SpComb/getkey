#!/usr/bin/env python

import argparse
import getpass
import gnomekeyring as gk
import random
import string
import subprocess
import sys

XSEL = 'xsel'

class Error (Exception) :
    pass

def invoke (cmd, *args) :
    def _invoke (stdin=None) :
        p = subprocess.Popen((cmd, ) + args, stdin=subprocess.PIPE)
        stdout, stderr = p.communicate(input=stdin)

        if stderr :
            print stderr

        return stdout
    
    return _invoke

def generate_key (length=16) :
    chars = string.letters + string.digits

    return ''.join(random.choice(chars) for i in xrange(length))

def test_locked (keyring) :
     return gk.get_info_sync(keyring).get_is_locked()

def prompt (prompt) :
    if sys.stdin.isatty() :
        return getpass.getpass(prompt)
    else :
        for line in sys.stdin :
            return line.rstrip('\n')

def unlock_keyring (keyring) :
    while True :
        try :
            secret = prompt("Password for keyring %s: " % (keyring, ))

            if not secret :
                return

            gk.unlock_sync(keyring, secret)
        except gk.IOError as ex :
            print >>sys.stderr, "Failed to unlock %s: %s" % (keyring, ex)
        else :
            return

def list_keys (keyring) :
    try :
        keys = gk.list_item_ids_sync(keyring)
    except gk.Error as ex :
        raise Error("%s: %s: %s" % (keyring, ex.__class__.__name__, ex))

    for key_id in keys :
        try :
            key = gk.item_get_info_sync(keyring, key_id)
        except gk.Error as ex :
            raise Error("%s[%s]: %s: %s" % (keyring, key_id, ex.__class__.__name__, ex))
        
        yield key

def get_key (keyring, key_name) :
    """
        Return secret for matching key.

        Returns None if not found.
    """
    for key in list_keys(keyring) :
        if key.get_display_name() == key_name :
            return key.get_secret()
    else:
        return None

def put_selection (options, text) :
    invoke(XSEL, '-pi')(text)

def put_key (keyring, key_name, secret, update=False) :
    exists = bool(get_key(keyring, key_name))

    if exists and not update:
        raise Error("%s: key already exists: %s" % (keyring, key_name))

    if update and not exists:
        raise Error("%s: key does not exist: %s" % (keyring, key_name))

    gk.item_create_sync(keyring, 
            type                = gk.ITEM_GENERIC_SECRET,
            display_name        = key_name, 
            attributes          = { },
            secret              = secret,
            update_if_exists    = True,
    )

def main (argv) :
    parser = argparse.ArgumentParser()
    parser.add_argument('-k', '--keyring', metavar='KEYRING',
            help="Name of keyring to find")
    parser.add_argument('-L', '--list-keyrings', action='store_true',
            help="List names of keyrings")
    parser.add_argument('-U', '--unlock', action='store_true',
            help="Unlock keyring if required")
    parser.add_argument('-l', '--list', action='store_true',
            help="List names of keys")
    parser.add_argument('-C', '--completion',
            help="List prefix-matching keys")
    parser.add_argument('-s', '--selection', action='store_true',
            help="Store to selection")
    parser.add_argument('-g', '--generate', action='store_true',
            help="Generate new key")
    parser.add_argument('--generate-length', type=int, default=16,
            help="Generate key length")
    parser.add_argument('-u', '--update', action='store_true',
            help="Regenerate existing key")
    parser.add_argument('key', nargs='*',
            help="Name of key")

    options = parser.parse_args(argv[1:])

    try :
        if options.list_keyrings :
            for keyring in gk.list_keyring_names_sync() :
                print keyring

        if options.unlock and test_locked(options.keyring) :
            unlock_keyring(options.keyring)

        if options.list or options.completion is not None :
            for key in list_keys(options.keyring) :
                key_name = key.get_display_name()

                if options.completion and not key_name.startswith(options.completion) :
                    continue

                print key_name
        
        for key in options.key :
            if options.generate or options.update :
                secret = generate_key(options.generate_length)
                put_key(options.keyring, key, secret,
                        update  = options.update,
                )
            else :
                secret = get_key(options.keyring, key)

            if options.selection :
                put_selection(options, secret)
            else :
                print secret
        

    except Error as ex :
        print >>sys.stderr, "Error:", ex
        return 1

    else :
        return 0

if __name__ == '__main__' :
    sys.exit(main(sys.argv))
