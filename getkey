#!/usr/bin/env python3

import argparse
import fnmatch
import os.path
import random
import secretstorage
import string
import subprocess
import sys

def cmd(cmd, *args, **env):
    """
        Return a wrapper for executing a command with args and stdin/stdout
    """
    def _invoke (stdin=None, stdout=True):
        p = subprocess.Popen((cmd, ) + args,
                stdin   = subprocess.PIPE if stdin else subprocess.DEVNULL,
                stdout  = subprocess.PIPE if stdout else subprocess.DEVNULL,
                env     = env or None,
        )
        stdout, stderr = p.communicate(input=stdin.encode('utf-8'))

        return stdout
    
    return _invoke

def selection(text, selection='primary', loops=None):
    """
        Place given text into the selection, waiting until copied and then returning.
    """

    if loops is None:
        cmd('xclip', '-selection', selection, '-in', '-silent')(text, stdout=False)
    else:
        cmd('xclip', '-selection', selection, '-loops', str(loops), '-quiet', '-in')(text, stdout=False)

GENERATE_LENGTH = 16
GENERATE_RANDOM = random.SystemRandom()
GENERATE_ALPHABET = string.ascii_letters + string.digits

def generate (length=GENERATE_LENGTH, random=GENERATE_RANDOM, alphabet=GENERATE_ALPHABET) :
    return ''.join(random.choice(alphabet) for i in range(length))

class Error(Exception):
    pass

def run(bus, args):
    # collections
    if args.list_keyrings:
        for collection in secretstorage.get_all_collections(bus):
            dir, name = os.path.split(collection.collection_path)

            assert dir == '/org/freedesktop/secrets/collection', "Invalid dir: " + dir

            print(name)
   
    # collection
    if args.keyring:
        path = os.path.join('/org/freedesktop/secrets/collection', args.keyring)

        try:
            collection = secretstorage.Collection(bus, path)
        except secretstorage.ItemNotFoundException:
            raise Error("Keyring not found: " + args.keyring)
    else:
        collection = secretstorage.get_default_collection(bus)

    if args.unlock and collection.is_locked():
        collection.unlock()

    # items
    if args.list:
        for item in collection.get_all_items():
            name = item.get_label()

            if args.key and not fnmatch.fnmatch(name, args.key):
                continue

            print(name)
            
            if args.verbose:
                for key, value in item.get_attributes().items():
                    print("", key, value)

    elif args.key:
        for item in collection.get_all_items():
            if item.get_label() == args.key:
                break
        else:
            item = None

        # secret
        if args.generate:
            secret = generate(
                    length  = args.generate_length,
            )
        elif item:
            secret = item.get_secret().decode('utf-8')
        else:
            raise Error("Key not found: " + args.key)
        
        # modify
        if args.update:
            item.set_secret(secret)

        elif args.generate:
            # create new, do not create a second copy or replace existing
            if item:
                raise Error("Key already exists: " + args.key)

            item = collection.create_item(args.key, {}, secret)

        # output
        if args.output:
            print(secret)

        if args.selection or args.selection_clipboard:
            selection(secret, selection='clipboard')
        if args.selection or args.selection_primary:
            selection(secret, selection='primary')

def main(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument('-L', '--list-keyrings', action='store_true',
            help="List available keyrings")
    parser.add_argument('-k', '--keyring', metavar='KEYRING',
            help="Name of keyring to find")
    parser.add_argument('-U', '--unlock', action='store_true',
            help="Unlock keyring if required")
    parser.add_argument('-l', '--list', action='store_true',
            help="List key names, filtering by given pattern")
    parser.add_argument('-v', '--verbose', action='store_true',
            help="List attributes")
    parser.add_argument('key', metavar='KEY', nargs='?',
            help="Key name, or list filter")
    parser.add_argument('-o', '--output', action='store_true',
            help="Output secret")
    parser.add_argument('--selection-clipboard', action='store_true',
            help="Select secret (copy into clipboard)")
    parser.add_argument('--selection-primary', action='store_true',
            help="Select secret (copy into primary)")
    parser.add_argument('-s', '--selection', action='store_true',
            help="Select secret (copy into clipboard+primary)")
    parser.add_argument('-g', '--generate', action='store_true',
            help="Generate new key")
    parser.add_argument('--generate-length', type=int, default=GENERATE_LENGTH,
            help="Generate key length")
    parser.add_argument('-u', '--update', action='store_true',
            help="Update existing key")

    args = parser.parse_args(argv[1:])

    try:
        bus = secretstorage.dbus_init()

        run(bus, args)

    except Error as error:
        print(error, file=sys.stderr)
        return 2

    else:
        return 0

if __name__ == '__main__' :
    sys.exit(main(sys.argv))
